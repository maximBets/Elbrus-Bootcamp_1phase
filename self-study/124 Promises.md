# 124 Promises. Материалы для самостоятельного изучения.

## Промисификация

Мы с вами разобрали два способа работы с асинхронными операциями. Первый - с помощью передачи коллбэка, а второй с помощью промисов. Но что делать если асинхронная функция принимает коллбэк, а нам нужен промис? Чтобы решить эту проблему используют "промисификацию".

К примеру, `setTimeout` принимает коллбэк, но не возвращает промис. Давай сделаем новую функцию setTimeoutPromised, которая будет возвращать промис:

```js
// ms - время задержки в миллисекундах
function setTimeoutPromised(ms) {
  return new Promise((resolve, reject) => {
    // промис зарезолвится через ms миллисекунд
    setTimeout(() => resolve(), ms);
  });
}

// использование
setTimeoutPromised(2000).then(() => {
  console.log('2 секунды прошло');
});
```

Теперь можно использовать функцию `setTimeoutPromised` и работать с промисами, а не с коллбэками.

Теперь для примера, давай представим, что имеем дело с функцией `fs.readFile`, которая принимает коллбэк и у нас нет аналога этой функции, которая бы возвращала промис. Вообще-то, ты знаешь что такой аналог есть (для этого нужно импортировать `fs` через `require('fs').promises`), но давай включим воображение и представим, что такой нет 🙂

Напишем функцию `readFilePromised`:

```js
const fs = require('fs');

function readFilePromised(path, encoding) {
  return new Promise((resolve, reject) => {
    fs.readFile(path, encoding, (error, data) => {
      if (error) {
        // реджектим промис если произошла ошибка во время чтения файла
        reject(error);
      } else {
        // резолвим промис если файл прочитался успешно
        resolve(data);
      }
    });
  });
}

// использование
readFilePromised('/path/to/file', 'utf8')
  .then((data) => {
    console.log(data);
  })
  .catch((error) => {
    console.error(error);
  });
```
