# 113 Debugging, Recursion, Algorithms. Материалы для самостоятельного изучения.

- [Что такое отладка? Отладка с помощью VS Code.](#что-такое-отладка-отладка-с-помощью-vs-code)
- [Алгоритмы](#алгоритмы)
  - [Сложность алгоритма. Линейный поиск.](#сложность-алгоритма-линейный-поиск)
  - [Бинарный поиск.](#бинарный-поиск)
  - [Пузырьковая сортировка массива](#пузырьковая-сортировка-массива)
  - [Так нужно ли оптимизировать наивное решение?](#так-нужно-ли-оптимизировать-наивное-решение)

## Что такое отладка? Отладка с помощью VS Code.

## Алгоритмы

Любой программа на языке программирования называется алгоритмом. Когда перед программистом встаёт задача то первое решение которое приходит ему в голову обычно называется "наивным". И это решение часто оказывается самым правильным. Однако, иногда то наивное решение требует слишком много ресурсов компьютера. В этом случае задачей программиста является найти или придумать самому более оптимальный алгоритм. Именно поиску и созданию таких оптимальных решений посвящён раздел программирования, который называется "Алгоритмы".

### Сложность алгоритма. Линейный поиск.

Для примера рассмотрим такую задачу. Нам отсортированный по возрастанию массив чисел. Нам нужно найти индекс конкретного числа. Например:

```js
// предположим, что длина массива numbers = 100
const numbers = [-200, -178, -150, ..., 123, 133, 170];
```

К примеру, в массиве numbers нам нужно найти индекс числа 88. Наивным решением здесь будет пробежаться по всему массиву (это называется `линейный поиск`). Даже если мы воспользуемся методом `indexOf` под капотом он всё равно пробежится по всему массиву. Сколько шагов потребует такой алгоритм в худшем случае? Худший случай - это когда число 88 будет последним элементом массива, а наш алгоритм потребует 100 шагов (по количеству элементов в массиве.

Теперь очень важное определение: `Сложность алгоритма` - это количество шагов, которое требуется алгоритму, чтобы решить задачу в худшем случае. Если количество шагов равно длине массива, то такую сложность обозначают `O(n)`, где `n` - это обозначение длины массива. Такая сложность называется линейной.

В целом, линейная сложность - это очень хорошая сложность, которую чаще всего не нужно оптимизировать. Однако, если наш массив будет очень длинным (1 000 000 или даже 1 000 000 000 элементов), то наша программа может начать притормаживать. Поэтому давайте посмотрим как можно упростить сложность алгоритма.

### Бинарный поиск.

Итак, ещё раз посмотрим на массив и попробуем найти в нём число 88 за минимальное количество шагов.

```js
const numbers = [-200, -178, -150, ..., 123, 133, 170];
```

Даже интуитивно можно понять, что лучше всего начинать не с начала, а с центра массива. Посмотрим чему будет равен центральный элемент. К примеру, `numbers[50] === 40`. Это значит, что следующим лучше проверить `numbers[75]`. Предположим `numbers[75] === 105`. Тогда следующим стоит проверить `numbers[62]`. И так далее, каждый раз деля массив пополам мы доберёмся до элемента 88. Такой алгоритм называется `бинарный поиск`.

Сколько в худшем случае нам потребуется сделать шагов? Сложность бинарного поиска - `O(log<sub>2</sub>n)`, двойку чаще всего опускают и пишут `O(log n)`. Если` n = 100`, то `log n ≈ 7`. Как видишь бинарный поиск работает гораздо быстрее чем линейный и чем больше длина массива тем больше будет отличие между этими двумя алгоритмами.

### Пузырьковая сортировка массива

Пузырьковая сортировка - это самый простой алгоритм сортировки, который проходит по массиву несколько раз и на каждом проходе сравнивает два соседних элемента и меняет их местами, если они не отсортированы в нужном порядке. Вот как он выглядит:

```js
let arr = [5, 2, 6, 1, 3, 9];

function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}

console.log(bubbleSort(arr)); // [1, 2, 3, 5, 6, 9]
```

Как видишь в алгоритме используется два вложенных друг в друга цикла, а это значит, что его сложность равна `O(n<sup>2</sup>)`, где `n` - количество элементов в массиве. Эта сложность называется квадратичной и это очень плохая сложность. Уже при количестве элементов 100 000 алгоритм сделает 10 000 000 000 шагов. Это заставит компьютер крепко призадуматься. Поэтому лучше воспользоваться другим алгоритмом сортировки.

Есть много оптимальный алгоритмов сортировки (quick sort, shell sort и т.д.). Их сложность чаще всего равна `O(n·log n)`. Если пользоваться встроенным методом `.sort` массива, то ты получишь именно такую сложность.

Давай посчитаем сколько шагов в худшем случае потребуется такому алгоритму если длинна массива будет 100 000:

`10000·log 10000 ≈ 132 880`

Как видишь 132 000 шагов намного меньше чем 10 000 000 000.

### Так нужно ли оптимизировать наивное решение?

Когда пишешь код, прикинь сколько примерно шагов может сделать твой алгоритм в худшем случае. Если меньше миллиона, то скорее всего наивное решение тебе подойдёт и не надо тратить время на поиск оптимального. Если больше - лучше поискать оптимальный алгоритм.
